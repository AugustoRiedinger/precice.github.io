<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>preCICE: extras/bindings/fortran/include/precice/SolverInterfaceFortran.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="additional.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">preCICE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_1510bd745cd29c20d24c27171ebe5ba5.html">extras</a></li><li class="navelem"><a class="el" href="dir_1eb3c5fb62f1dc438e71781d575d7c6f.html">bindings</a></li><li class="navelem"><a class="el" href="dir_27c2afb197cdba1454b5a7bb6e353759.html">fortran</a></li><li class="navelem"><a class="el" href="dir_1eba3de691be5954346f1b8fe16635ba.html">include</a></li><li class="navelem"><a class="el" href="dir_9ad571208643be02e2dfd14c02c437a2.html">precice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SolverInterfaceFortran.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;precice/export.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for SolverInterfaceFortran.hpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp__incl.svg" width="238" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp__dep__incl.svg" width="238" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="SolverInterfaceFortran_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0eb04cc16b081ab895fdded8292a3bd4"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a0eb04cc16b081ab895fdded8292a3bd4">precicef_create_</a> (const char *participantName, const char *configFileName, const int *solverProcessIndex, const int *solverProcessSize, int lengthAccessorName, int lengthConfigFileName)</td></tr>
<tr class="memdesc:a0eb04cc16b081ab895fdded8292a3bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SolverInterface for the given participant.  <a href="SolverInterfaceFortran_8hpp.html#a0eb04cc16b081ab895fdded8292a3bd4">More...</a><br /></td></tr>
<tr class="separator:a0eb04cc16b081ab895fdded8292a3bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9fcca05be3dcd084c6b62f1abb0414"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#abc9fcca05be3dcd084c6b62f1abb0414">precicef_initialize_</a> (double *timestepLengthLimit)</td></tr>
<tr class="memdesc:abc9fcca05be3dcd084c6b62f1abb0414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully initializes preCICE and coupling data.  <a href="SolverInterfaceFortran_8hpp.html#abc9fcca05be3dcd084c6b62f1abb0414">More...</a><br /></td></tr>
<tr class="separator:abc9fcca05be3dcd084c6b62f1abb0414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22361bc8310f4341f72f0f8df02e0e0"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#aa22361bc8310f4341f72f0f8df02e0e0">precicef_advance_</a> (double *timestepLengthLimit)</td></tr>
<tr class="memdesc:aa22361bc8310f4341f72f0f8df02e0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances preCICE after the solver has computed one timestep.  <a href="SolverInterfaceFortran_8hpp.html#aa22361bc8310f4341f72f0f8df02e0e0">More...</a><br /></td></tr>
<tr class="separator:aa22361bc8310f4341f72f0f8df02e0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6594f1254059962a03ba06d313c57f"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#add6594f1254059962a03ba06d313c57f">precicef_finalize_</a> ()</td></tr>
<tr class="memdesc:add6594f1254059962a03ba06d313c57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes preCICE.  <a href="SolverInterfaceFortran_8hpp.html#add6594f1254059962a03ba06d313c57f">More...</a><br /></td></tr>
<tr class="separator:add6594f1254059962a03ba06d313c57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab763621a5310cbc47f4f01ed09b1e9cc"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ab763621a5310cbc47f4f01ed09b1e9cc">precicef_get_dims_</a> (int *dimensions)</td></tr>
<tr class="memdesc:ab763621a5310cbc47f4f01ed09b1e9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of spatial dimensions configured.  <a href="SolverInterfaceFortran_8hpp.html#ab763621a5310cbc47f4f01ed09b1e9cc">More...</a><br /></td></tr>
<tr class="separator:ab763621a5310cbc47f4f01ed09b1e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af835e0a7ff5ee538130739fdd8ac2fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#af835e0a7ff5ee538130739fdd8ac2fa9">precicef_ongoing_</a> (int *isOngoing)</td></tr>
<tr class="separator:af835e0a7ff5ee538130739fdd8ac2fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68016ecdd5108f00757cbad3a5f81f02"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a68016ecdd5108f00757cbad3a5f81f02">precicef_is_coupling_ongoing_</a> (int *isOngoing)</td></tr>
<tr class="memdesc:a68016ecdd5108f00757cbad3a5f81f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the coupled simulation is still ongoing.  <a href="SolverInterfaceFortran_8hpp.html#a68016ecdd5108f00757cbad3a5f81f02">More...</a><br /></td></tr>
<tr class="separator:a68016ecdd5108f00757cbad3a5f81f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9656f4f1c15f61423889312e2876d164"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a9656f4f1c15f61423889312e2876d164">precicef_is_time_window_complete_</a> (int *isComplete)</td></tr>
<tr class="memdesc:a9656f4f1c15f61423889312e2876d164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current coupling window is completed.  <a href="SolverInterfaceFortran_8hpp.html#a9656f4f1c15f61423889312e2876d164">More...</a><br /></td></tr>
<tr class="separator:a9656f4f1c15f61423889312e2876d164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7854d0a3179c9d73000cbdd6de1c200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ae7854d0a3179c9d73000cbdd6de1c200">precicef_action_required_</a> (const char *action, int *isRequired, int lengthAction)</td></tr>
<tr class="memdesc:ae7854d0a3179c9d73000cbdd6de1c200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided action is required.  <a href="SolverInterfaceFortran_8hpp.html#ae7854d0a3179c9d73000cbdd6de1c200">More...</a><br /></td></tr>
<tr class="separator:ae7854d0a3179c9d73000cbdd6de1c200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fa84325285fa8313d911a6701d20b"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a6d3fa84325285fa8313d911a6701d20b">precicef_is_action_required_</a> (const char *action, int *isRequired, int lengthAction)</td></tr>
<tr class="memdesc:a6d3fa84325285fa8313d911a6701d20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided action is required.  <a href="SolverInterfaceFortran_8hpp.html#a6d3fa84325285fa8313d911a6701d20b">More...</a><br /></td></tr>
<tr class="separator:a6d3fa84325285fa8313d911a6701d20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018c649ec371258d4f08d57713a9687d"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a018c649ec371258d4f08d57713a9687d">precicef_mark_action_fulfilled_</a> (const char *action, int lengthAction)</td></tr>
<tr class="memdesc:a018c649ec371258d4f08d57713a9687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates preCICE that a required action has been fulfilled by a solver.  <a href="SolverInterfaceFortran_8hpp.html#a018c649ec371258d4f08d57713a9687d">More...</a><br /></td></tr>
<tr class="separator:a018c649ec371258d4f08d57713a9687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f56518e6cb3846798253b29e017be11"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a1f56518e6cb3846798253b29e017be11">precicef_has_mesh_</a> (const char *meshName, int *hasMesh, int lengthMeshName)</td></tr>
<tr class="memdesc:a1f56518e6cb3846798253b29e017be11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the mesh with given name is used by a solver.  <a href="SolverInterfaceFortran_8hpp.html#a1f56518e6cb3846798253b29e017be11">More...</a><br /></td></tr>
<tr class="separator:a1f56518e6cb3846798253b29e017be11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae540c241ecb1046a38d0c04d94a7dcb"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#aae540c241ecb1046a38d0c04d94a7dcb">precicef_get_mesh_id_</a> (const char *meshName, int *meshID, int lengthMeshName)</td></tr>
<tr class="memdesc:aae540c241ecb1046a38d0c04d94a7dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID belonging to the mesh with given name.  <a href="SolverInterfaceFortran_8hpp.html#aae540c241ecb1046a38d0c04d94a7dcb">More...</a><br /></td></tr>
<tr class="separator:aae540c241ecb1046a38d0c04d94a7dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bd44bb3faffcec7ce1643e1f499bc3"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a55bd44bb3faffcec7ce1643e1f499bc3">precicef_has_data_</a> (const char *dataName, const int *meshID, int *hasData, int lengthDataName)</td></tr>
<tr class="memdesc:a55bd44bb3faffcec7ce1643e1f499bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the data with given name is used by a solver and mesh.  <a href="SolverInterfaceFortran_8hpp.html#a55bd44bb3faffcec7ce1643e1f499bc3">More...</a><br /></td></tr>
<tr class="separator:a55bd44bb3faffcec7ce1643e1f499bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ed4f962fe04cb7270d02470b43b8c9"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a69ed4f962fe04cb7270d02470b43b8c9">precicef_get_data_id_</a> (const char *dataName, const int *meshID, int *dataID, int lengthDataName)</td></tr>
<tr class="memdesc:a69ed4f962fe04cb7270d02470b43b8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of the data associated with the given name and mesh.  <a href="SolverInterfaceFortran_8hpp.html#a69ed4f962fe04cb7270d02470b43b8c9">More...</a><br /></td></tr>
<tr class="separator:a69ed4f962fe04cb7270d02470b43b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c454ddcb88e2a05cb7aa0977199ec8e"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a4c454ddcb88e2a05cb7aa0977199ec8e">precicef_is_mesh_connectivity_required_</a> (const int *meshID, int *required)</td></tr>
<tr class="memdesc:a4c454ddcb88e2a05cb7aa0977199ec8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given mesh requires connectivity.  <a href="SolverInterfaceFortran_8hpp.html#a4c454ddcb88e2a05cb7aa0977199ec8e">More...</a><br /></td></tr>
<tr class="separator:a4c454ddcb88e2a05cb7aa0977199ec8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448b90ad9522fad694e8d75c5bb58ee3"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a448b90ad9522fad694e8d75c5bb58ee3">precicef_set_vertex_</a> (const int *meshID, const double *position, int *vertexID)</td></tr>
<tr class="memdesc:a448b90ad9522fad694e8d75c5bb58ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mesh vertex.  <a href="SolverInterfaceFortran_8hpp.html#a448b90ad9522fad694e8d75c5bb58ee3">More...</a><br /></td></tr>
<tr class="separator:a448b90ad9522fad694e8d75c5bb58ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b8925d2d56246ae6712f465ad4a11d"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ab1b8925d2d56246ae6712f465ad4a11d">precicef_get_mesh_vertex_size_</a> (const int *meshID, int *meshSize)</td></tr>
<tr class="memdesc:ab1b8925d2d56246ae6712f465ad4a11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices of a mesh.  <a href="SolverInterfaceFortran_8hpp.html#ab1b8925d2d56246ae6712f465ad4a11d">More...</a><br /></td></tr>
<tr class="separator:ab1b8925d2d56246ae6712f465ad4a11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0282309e6095d5cece8e77f980d4ffd9"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a0282309e6095d5cece8e77f980d4ffd9">precicef_set_vertices_</a> (const int *meshID, const int *size, double *positions, int *positionIDs)</td></tr>
<tr class="memdesc:a0282309e6095d5cece8e77f980d4ffd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates multiple mesh vertices.  <a href="SolverInterfaceFortran_8hpp.html#a0282309e6095d5cece8e77f980d4ffd9">More...</a><br /></td></tr>
<tr class="separator:a0282309e6095d5cece8e77f980d4ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf01967f1a0f1af51ecc3f058ebb72bd"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#acf01967f1a0f1af51ecc3f058ebb72bd">precicef_get_vertices_</a> (const int *meshID, const int *size, int *ids, double *positions)</td></tr>
<tr class="memdesc:acf01967f1a0f1af51ecc3f058ebb72bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vertex positions for multiple vertex ids from a given mesh.  <a href="SolverInterfaceFortran_8hpp.html#acf01967f1a0f1af51ecc3f058ebb72bd">More...</a><br /></td></tr>
<tr class="separator:acf01967f1a0f1af51ecc3f058ebb72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae162bb4c9e9d90699019e36d2486436c"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ae162bb4c9e9d90699019e36d2486436c">precicef_get_vertex_ids_from_positions_</a> (const int *meshID, const int *size, double *positions, int *ids)</td></tr>
<tr class="memdesc:ae162bb4c9e9d90699019e36d2486436c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets mesh vertex IDs from positions.  <a href="SolverInterfaceFortran_8hpp.html#ae162bb4c9e9d90699019e36d2486436c">More...</a><br /></td></tr>
<tr class="separator:ae162bb4c9e9d90699019e36d2486436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bccd3a896f283222c2084b0815b1113"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a4bccd3a896f283222c2084b0815b1113">precicef_set_edge_</a> (const int *meshID, const int *firstVertexID, const int *secondVertexID)</td></tr>
<tr class="memdesc:a4bccd3a896f283222c2084b0815b1113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a mesh edge from vertex IDs.  <a href="SolverInterfaceFortran_8hpp.html#a4bccd3a896f283222c2084b0815b1113">More...</a><br /></td></tr>
<tr class="separator:a4bccd3a896f283222c2084b0815b1113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5cfece0a1721e234688f34fd1dd984"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a7b5cfece0a1721e234688f34fd1dd984">precicef_set_mesh_edges_</a> (const int *meshID, const int *size, const int *vertices)</td></tr>
<tr class="memdesc:a7b5cfece0a1721e234688f34fd1dd984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multiple mesh edge from vertex IDs.  <a href="SolverInterfaceFortran_8hpp.html#a7b5cfece0a1721e234688f34fd1dd984">More...</a><br /></td></tr>
<tr class="separator:a7b5cfece0a1721e234688f34fd1dd984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d85060651c172402e56cb020130021"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a45d85060651c172402e56cb020130021">precicef_set_triangle_</a> (const int *meshID, const int *firstVertexID, const int *secondVertexID, const int *thirdVertexID)</td></tr>
<tr class="memdesc:a45d85060651c172402e56cb020130021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mesh triangle from vertex IDs.  <a href="SolverInterfaceFortran_8hpp.html#a45d85060651c172402e56cb020130021">More...</a><br /></td></tr>
<tr class="separator:a45d85060651c172402e56cb020130021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960303a9aa514bc53f8a3fa5077221e5"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a960303a9aa514bc53f8a3fa5077221e5">precicef_set_quad_</a> (const int *meshID, const int *firstVertexID, const int *secondVertexID, const int *thirdVertexID, const int *fourthVertexID)</td></tr>
<tr class="memdesc:a960303a9aa514bc53f8a3fa5077221e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a planar surface mesh quadrangle from vertex IDs.  <a href="SolverInterfaceFortran_8hpp.html#a960303a9aa514bc53f8a3fa5077221e5">More...</a><br /></td></tr>
<tr class="separator:a960303a9aa514bc53f8a3fa5077221e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d65a5422d2408c820ba4f5c5f17868"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#aa5d65a5422d2408c820ba4f5c5f17868">precicef_set_mesh_quads_</a> (const int *meshID, const int *size, const int *vertices)</td></tr>
<tr class="memdesc:aa5d65a5422d2408c820ba4f5c5f17868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multiple mesh quads from vertex IDs.  <a href="SolverInterfaceFortran_8hpp.html#aa5d65a5422d2408c820ba4f5c5f17868">More...</a><br /></td></tr>
<tr class="separator:aa5d65a5422d2408c820ba4f5c5f17868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e219ea4d5f59d6289e2c6b415804492"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a2e219ea4d5f59d6289e2c6b415804492">precicef_set_tetrahedron</a> (const int *meshID, const int *firstVertexID, const int *secondVertexID, const int *thirdVertexID, const int *fourthVertexID)</td></tr>
<tr class="memdesc:a2e219ea4d5f59d6289e2c6b415804492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tetrahedron in 3D mesh from vertex ID.  <a href="SolverInterfaceFortran_8hpp.html#a2e219ea4d5f59d6289e2c6b415804492">More...</a><br /></td></tr>
<tr class="separator:a2e219ea4d5f59d6289e2c6b415804492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bd62b234cadc370d120e6ec83cd142"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a16bd62b234cadc370d120e6ec83cd142">precicef_set_mesh_tetrahedra_</a> (const int *meshID, const int *size, const int *vertices)</td></tr>
<tr class="memdesc:a16bd62b234cadc370d120e6ec83cd142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multiple mesh tetrahedra from vertex IDs.  <a href="SolverInterfaceFortran_8hpp.html#a16bd62b234cadc370d120e6ec83cd142">More...</a><br /></td></tr>
<tr class="separator:a16bd62b234cadc370d120e6ec83cd142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fd666371672a87a6e6b4ee7267e1ab"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a68fd666371672a87a6e6b4ee7267e1ab">precicef_write_bvdata_</a> (const int *dataID, const int *size, int *valueIndices, double *values)</td></tr>
<tr class="memdesc:a68fd666371672a87a6e6b4ee7267e1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes vector data given as block.  <a href="SolverInterfaceFortran_8hpp.html#a68fd666371672a87a6e6b4ee7267e1ab">More...</a><br /></td></tr>
<tr class="separator:a68fd666371672a87a6e6b4ee7267e1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf9e3af0454b813fb64a6d7ca10da63"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a5bf9e3af0454b813fb64a6d7ca10da63">precicef_write_vdata_</a> (const int *dataID, const int *valueIndex, const double *dataValue)</td></tr>
<tr class="memdesc:a5bf9e3af0454b813fb64a6d7ca10da63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes vector data to a vertex.  <a href="SolverInterfaceFortran_8hpp.html#a5bf9e3af0454b813fb64a6d7ca10da63">More...</a><br /></td></tr>
<tr class="separator:a5bf9e3af0454b813fb64a6d7ca10da63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d504dd8043f8e8e293db5fdf27e012"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a63d504dd8043f8e8e293db5fdf27e012">precicef_write_bsdata_</a> (const int *dataID, const int *size, int *valueIndices, double *values)</td></tr>
<tr class="memdesc:a63d504dd8043f8e8e293db5fdf27e012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes scalar data given as block.  <a href="SolverInterfaceFortran_8hpp.html#a63d504dd8043f8e8e293db5fdf27e012">More...</a><br /></td></tr>
<tr class="separator:a63d504dd8043f8e8e293db5fdf27e012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98005b1ae5940cdecdf8866784e8c04"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ac98005b1ae5940cdecdf8866784e8c04">precicef_write_sdata_</a> (const int *dataID, const int *valueIndex, const double *dataValue)</td></tr>
<tr class="memdesc:ac98005b1ae5940cdecdf8866784e8c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes scalar data to a vertex.  <a href="SolverInterfaceFortran_8hpp.html#ac98005b1ae5940cdecdf8866784e8c04">More...</a><br /></td></tr>
<tr class="separator:ac98005b1ae5940cdecdf8866784e8c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5df9e3756f761649a05cb124d66c82"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a4d5df9e3756f761649a05cb124d66c82">precicef_read_bvdata_</a> (const int *dataID, const int *size, int *valueIndices, double *values)</td></tr>
<tr class="memdesc:a4d5df9e3756f761649a05cb124d66c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads vector data values given as block from a mesh. Values correspond to the end of the current time window.  <a href="SolverInterfaceFortran_8hpp.html#a4d5df9e3756f761649a05cb124d66c82">More...</a><br /></td></tr>
<tr class="separator:a4d5df9e3756f761649a05cb124d66c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b96e17d6d06a6190df8f1d669d7c35"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a79b96e17d6d06a6190df8f1d669d7c35">precicef_read_vdata_</a> (const int *dataID, const int *valueIndex, double *dataValue)</td></tr>
<tr class="memdesc:a79b96e17d6d06a6190df8f1d669d7c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads vector data at a vertex on a mesh. Values correspond to the end of the current time window.  <a href="SolverInterfaceFortran_8hpp.html#a79b96e17d6d06a6190df8f1d669d7c35">More...</a><br /></td></tr>
<tr class="separator:a79b96e17d6d06a6190df8f1d669d7c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848befad97e6f37a2547f14ebb579cb3"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a848befad97e6f37a2547f14ebb579cb3">precicef_read_bsdata_</a> (const int *dataID, const int *size, int *valueIndices, double *values)</td></tr>
<tr class="memdesc:a848befad97e6f37a2547f14ebb579cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads scalar data values given as block from a mesh. Values correspond to the end of the current time window.  <a href="SolverInterfaceFortran_8hpp.html#a848befad97e6f37a2547f14ebb579cb3">More...</a><br /></td></tr>
<tr class="separator:a848befad97e6f37a2547f14ebb579cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24364703bad142cc933a62b8f8989b2"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#af24364703bad142cc933a62b8f8989b2">precicef_read_sdata_</a> (const int *dataID, const int *valueIndex, double *dataValue)</td></tr>
<tr class="memdesc:af24364703bad142cc933a62b8f8989b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads scalar data at a vertex on a mesh. Values correspond to the end of the current time window.  <a href="SolverInterfaceFortran_8hpp.html#af24364703bad142cc933a62b8f8989b2">More...</a><br /></td></tr>
<tr class="separator:af24364703bad142cc933a62b8f8989b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f8656df004c9a530da5aa5855b6577"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#aa6f8656df004c9a530da5aa5855b6577">precicef_action_write_iter_checkp_</a> (char *nameAction, int lengthNameAction)</td></tr>
<tr class="memdesc:aa6f8656df004c9a530da5aa5855b6577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of action for writing iteration checkpoint.  <a href="SolverInterfaceFortran_8hpp.html#aa6f8656df004c9a530da5aa5855b6577">More...</a><br /></td></tr>
<tr class="separator:aa6f8656df004c9a530da5aa5855b6577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8835b33b92e134314343782ee55bf853"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a8835b33b92e134314343782ee55bf853">precicef_action_write_initial_data_</a> (char *nameAction, int lengthNameAction)</td></tr>
<tr class="memdesc:a8835b33b92e134314343782ee55bf853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of action for writing initial data.  <a href="SolverInterfaceFortran_8hpp.html#a8835b33b92e134314343782ee55bf853">More...</a><br /></td></tr>
<tr class="separator:a8835b33b92e134314343782ee55bf853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ce8aab1c2335769512b72194bbf2de"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a24ce8aab1c2335769512b72194bbf2de">precicef_action_read_iter_checkp_</a> (char *nameAction, int lengthNameAction)</td></tr>
<tr class="memdesc:a24ce8aab1c2335769512b72194bbf2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of action for reading iteration checkpoint.  <a href="SolverInterfaceFortran_8hpp.html#a24ce8aab1c2335769512b72194bbf2de">More...</a><br /></td></tr>
<tr class="separator:a24ce8aab1c2335769512b72194bbf2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091ddb804011840dff5b54807cff39b1"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a091ddb804011840dff5b54807cff39b1">precicef_get_version_information_</a> (char *versionInfo, int lengthVersionInfo)</td></tr>
<tr class="separator:a091ddb804011840dff5b54807cff39b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Experimental Data Access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These API functions are <b>experimental</b> and may change in future versions. </p>
</div></td></tr>
<tr class="memitem:a702560446f6d3a307e3f292e8b2c5b18"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a702560446f6d3a307e3f292e8b2c5b18">precicef_is_gradient_data_required_</a> (const int *dataID, int *required)</td></tr>
<tr class="memdesc:a702560446f6d3a307e3f292e8b2c5b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given data set requires gradient data. We check if the data object has been initialized with the gradient flag.  <a href="SolverInterfaceFortran_8hpp.html#a702560446f6d3a307e3f292e8b2c5b18">More...</a><br /></td></tr>
<tr class="separator:a702560446f6d3a307e3f292e8b2c5b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af160c41c24197f348459bc9d400dee5c"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#af160c41c24197f348459bc9d400dee5c">precicef_write_sgradient_data_</a> (const int *dataID, const int *valueIndex, const double *gradientValues)</td></tr>
<tr class="memdesc:af160c41c24197f348459bc9d400dee5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes scalar gradient data to a vertex.  <a href="SolverInterfaceFortran_8hpp.html#af160c41c24197f348459bc9d400dee5c">More...</a><br /></td></tr>
<tr class="separator:af160c41c24197f348459bc9d400dee5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd135b00dfc8b28a17f668ebf380e18"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a6bd135b00dfc8b28a17f668ebf380e18">precicef_write_bsgradient_data_</a> (const int *dataID, const int *size, const int *valueIndices, const double *gradientValues)</td></tr>
<tr class="memdesc:a6bd135b00dfc8b28a17f668ebf380e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes scalar gradient data given as block.  <a href="SolverInterfaceFortran_8hpp.html#a6bd135b00dfc8b28a17f668ebf380e18">More...</a><br /></td></tr>
<tr class="separator:a6bd135b00dfc8b28a17f668ebf380e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3abc96e19d89d277a2a2ad02805e27d"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ac3abc96e19d89d277a2a2ad02805e27d">precicef_write_vgradient_data_</a> (const int *dataID, const int *valueIndex, const double *gradientValues)</td></tr>
<tr class="memdesc:ac3abc96e19d89d277a2a2ad02805e27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes vector gradient data to a vertex.  <a href="SolverInterfaceFortran_8hpp.html#ac3abc96e19d89d277a2a2ad02805e27d">More...</a><br /></td></tr>
<tr class="separator:ac3abc96e19d89d277a2a2ad02805e27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61ef25602fbde42bb43521958fd65dd"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#aa61ef25602fbde42bb43521958fd65dd">precicef_write_bvgradient_data_</a> (const int *dataID, const int *size, const int *valueIndices, const double *gradientValues)</td></tr>
<tr class="memdesc:aa61ef25602fbde42bb43521958fd65dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes vector gradient data given as block.  <a href="SolverInterfaceFortran_8hpp.html#aa61ef25602fbde42bb43521958fd65dd">More...</a><br /></td></tr>
<tr class="separator:aa61ef25602fbde42bb43521958fd65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18998f476f957f0bfe28631e1fcc7228"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#a18998f476f957f0bfe28631e1fcc7228">precicef_set_mesh_access_region_</a> (const int meshID, const double *boundingBox)</td></tr>
<tr class="memdesc:a18998f476f957f0bfe28631e1fcc7228"><td class="mdescLeft">&#160;</td><td class="mdescRight">setMeshAccessRegion Define a region of interest on a received mesh (&lt;receive-mesh ... from="otherParticipant /&gt;") in order to receive only a certain mesh region. Have a look at the website under <a href="https://precice.org/couple-your-code-direct-access.html">https://precice.org/couple-your-code-direct-access.html</a> or navigate manually to the page Docs-&gt;Couple your code -&gt; Advanced topics -&gt; Accessing received meshes directly for a comprehensive documentation  <a href="SolverInterfaceFortran_8hpp.html#a18998f476f957f0bfe28631e1fcc7228">More...</a><br /></td></tr>
<tr class="separator:a18998f476f957f0bfe28631e1fcc7228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f7b0cf06b414eafa58b7255aff071"><td class="memItemLeft" align="right" valign="top">PRECICE_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SolverInterfaceFortran_8hpp.html#ae96f7b0cf06b414eafa58b7255aff071">precicef_get_mesh_vertices_and_IDs_</a> (const int meshID, const int size, int *ids, double *coordinates)</td></tr>
<tr class="memdesc:ae96f7b0cf06b414eafa58b7255aff071"><td class="mdescLeft">&#160;</td><td class="mdescRight">getMeshVerticesAndIDs Iterates over the region of interest defined by bounding boxes and reads the corresponding coordinates omitting the mapping.  <a href="SolverInterfaceFortran_8hpp.html#ae96f7b0cf06b414eafa58b7255aff071">More...</a><br /></td></tr>
<tr class="separator:ae96f7b0cf06b414eafa58b7255aff071"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains a Fortran 77 compatible interface written in C/C++.</p>
<p>Every method has a Fortran syntax equivalent in the method comment, and a listing for input and output variables. A variable can be input and output at the same time. </p>

<p class="definition">Definition in file <a class="el" href="SolverInterfaceFortran_8hpp_source.html">SolverInterfaceFortran.hpp</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a24ce8aab1c2335769512b72194bbf2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ce8aab1c2335769512b72194bbf2de">&#9670;&nbsp;</a></span>precicef_action_read_iter_checkp_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_action_read_iter_checkp_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>nameAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthNameAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of action for reading iteration checkpoint. </p>
<p>Fortran syntax: precicef_action_read_iter_checkpoint( CHARACTER nameAction(*) ) </p>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00456">456</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a24ce8aab1c2335769512b72194bbf2de_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ae7854d0a3179c9d73000cbdd6de1c200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7854d0a3179c9d73000cbdd6de1c200">&#9670;&nbsp;</a></span>precicef_action_required_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void precicef_action_required_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the provided action is required. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Forwards to precicef_is_action_required_</dd></dl>
<p>Fortran syntax: precicef_action_required( CHARACTER action(*), INTEGER isRequired )</p>
<p>IN: action OUT: isRequired(1:true, 0:false)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>the name of the action </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the action is required</dd></dl>
<p>Some features of preCICE require a solver to perform specific actions, in order to be in valid state for a coupled simulation. A solver is made eligible to use those features, by querying for the required actions, performing them on demand, and calling markActionFulfilled() to signalize preCICE the correct behavior of the solver.</p>
<dl class="section see"><dt>See also</dt><dd>markActionFulfilled() </dd>
<dd>
cplscheme::constants </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00115">115</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_ae7854d0a3179c9d73000cbdd6de1c200_cgraph.svg" width="646" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8835b33b92e134314343782ee55bf853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8835b33b92e134314343782ee55bf853">&#9670;&nbsp;</a></span>precicef_action_write_initial_data_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_action_write_initial_data_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>nameAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthNameAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of action for writing initial data. </p>
<p>FortranSyntax: precicef_action_write_initial_data( CHARACTER nameAction(*) ) </p>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00445">445</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a8835b33b92e134314343782ee55bf853_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="aa6f8656df004c9a530da5aa5855b6577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f8656df004c9a530da5aa5855b6577">&#9670;&nbsp;</a></span>precicef_action_write_iter_checkp_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_action_write_iter_checkp_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>nameAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthNameAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of action for writing iteration checkpoint. </p>
<p>Fortran syntax: precicef_action_write_iter_checkpoint( CHARACTER nameAction(*) ) </p>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00434">434</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_aa6f8656df004c9a530da5aa5855b6577_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="aa22361bc8310f4341f72f0f8df02e0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22361bc8310f4341f72f0f8df02e0e0">&#9670;&nbsp;</a></span>precicef_advance_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_advance_ </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>timestepLengthLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances preCICE after the solver has computed one timestep. </p>
<p>Fortran syntax: precicef_advance( DOUBLE PRECISION timstepLengthLimit )</p>
<p>IN: timestepLengthLimit OUT: timestepLengthLimit</p>
<ul>
<li>Sends and resets coupling data written by solver to coupling partners.</li>
</ul>
<p>Receives coupling data read by solver.</p><ul>
<li>Computes and applies data mappings.</li>
<li>Computes acceleration of coupling data.</li>
<li>Exchanges and computes information regarding the state of the coupled simulation.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">computedTimestepLength</td><td>Length of timestep used by the solver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has been called successfully. </dd>
<dd>
The solver has computed one timestep. </dd>
<dd>
The solver has written all coupling data. </dd>
<dd>
isCouplngOngoing() returns true. </dd>
<dd>
finalize() has not yet been called.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Coupling data values specified in the configuration are exchanged. </dd>
<dd>
Coupling scheme state (computed time, computed timesteps, ...) is updated. </dd>
<dd>
The coupling state is logged. </dd>
<dd>
Configured data mapping schemes are applied. </dd>
<dd>
[Second Participant] Configured acceleration schemes are applied. </dd>
<dd>
Meshes with data are exported to files if configured.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum length of next timestep to be computed by solver. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00066">66</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a0eb04cc16b081ab895fdded8292a3bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb04cc16b081ab895fdded8292a3bd4">&#9670;&nbsp;</a></span>precicef_create_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_create_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>participantName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>configFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>solverProcessIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>solverProcessSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthAccessorName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthConfigFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SolverInterface for the given participant. </p>
<p>Fortran syntax: precicef_create( CHARACTER participantName(*), CHARACTER configFileName(*), INTEGER solverProcessIndex, INTEGER solverProcessSize )</p>
<p>IN: participantName, configFileName, solverProcessIndex, solverProcessSize OUT: -</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">participantName</td><td>Name of the participant using the interface. Has to match the name given for a participant in the xml configuration file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configurationFileName</td><td>Name (with path) of the xml configuration file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solverProcessIndex</td><td>If the solver code runs with several processes, each process using preCICE has to specify its index, which has to start from 0 and end with solverProcessSize - 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solverProcessSize</td><td>The number of solver processes using preCICE. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00036">36</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a0eb04cc16b081ab895fdded8292a3bd4_cgraph.svg" width="399" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="add6594f1254059962a03ba06d313c57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6594f1254059962a03ba06d313c57f">&#9670;&nbsp;</a></span>precicef_finalize_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_finalize_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes preCICE. </p>
<p>Fortran syntax: precicef_finalize();</p>
<p>If initialize() has been called:</p>
<ul>
<li>Synchronizes with remote participants</li>
<li>handles final exports</li>
<li>cleans up general state</li>
</ul>
<p>Always:</p>
<ul>
<li>flushes and finalizes Events</li>
<li>finalizes managed PETSc</li>
<li>finalizes managed MPI</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>finalize() has not been called.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Communication channels are closed. </dd>
<dd>
Meshes and data are deallocated </dd>
<dd>
Finalized managed PETSc </dd>
<dd>
Finalized managed MPI</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isCouplingOngoing() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00073">73</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a69ed4f962fe04cb7270d02470b43b8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ed4f962fe04cb7270d02470b43b8c9">&#9670;&nbsp;</a></span>precicef_get_data_id_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_data_id_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthDataName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of the data associated with the given name and mesh. </p>
<p>The given name (dataName) has to be one of the names specified in the configuration file. The data id obtained can be used to read and write data to and from the coupling mesh.</p>
<p>Fortran syntax: precicef_get_data_id( CHARACTER dataName(*), INTEGER meshID, INTEGER dataID, INTEGER lengthDataName)</p>
<p>IN: dataName IN: meshID OUT: dataID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataName</td><td>the name of the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the associated mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the corresponding data </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00199">199</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a69ed4f962fe04cb7270d02470b43b8c9_cgraph.svg" width="434" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab763621a5310cbc47f4f01ed09b1e9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab763621a5310cbc47f4f01ed09b1e9cc">&#9670;&nbsp;</a></span>precicef_get_dims_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_dims_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of spatial dimensions configured. </p>
<p>Fortran syntax: precicef_get_dims( INTEGER dimensions )</p>
<p>IN: - OUT: dimensions</p>
<dl class="section return"><dt>Returns</dt><dd>the configured dimension</dd></dl>
<p>Currently, two and three dimensional problems can be solved using preCICE. The dimension is specified in the XML configuration. </p>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00080">80</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="aae540c241ecb1046a38d0c04d94a7dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae540c241ecb1046a38d0c04d94a7dcb">&#9670;&nbsp;</a></span>precicef_get_mesh_id_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_mesh_id_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthMeshName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID belonging to the mesh with given name. </p>
<p>Fortran syntax: precicef_get_mesh_id( CHARACTER meshName(*), INTEGER meshID )</p>
<p>IN: meshName OUT: meshID</p>
<p>The existing names are determined from the configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshName</td><td>the name of the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the corresponding mesh </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00172">172</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_aae540c241ecb1046a38d0c04d94a7dcb_cgraph.svg" width="440" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab1b8925d2d56246ae6712f465ad4a11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b8925d2d56246ae6712f465ad4a11d">&#9670;&nbsp;</a></span>precicef_get_mesh_vertex_size_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_mesh_vertex_size_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>meshSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertices of a mesh. </p>
<p>Fortran syntax: precicef_get_mesh_vertex_size( INTEGER meshID, INTEGER meshSize )</p>
<p>IN: meshID OUT: meshSize</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of the vertices of the mesh</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This function can be called on received meshes as well as provided meshes. However, you need to call this function after <code>initialize()</code>, if the <code>meshID</code> corresponds to a received mesh, since the relevant mesh data is exchanged during the <code>initialize()</code> call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00232">232</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="ae96f7b0cf06b414eafa58b7255aff071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96f7b0cf06b414eafa58b7255aff071">&#9670;&nbsp;</a></span>precicef_get_mesh_vertices_and_IDs_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_mesh_vertices_and_IDs_ </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getMeshVerticesAndIDs Iterates over the region of interest defined by bounding boxes and reads the corresponding coordinates omitting the mapping. </p>
<p>Fortran syntax: precicef_get_mesh_vertices_and_IDs_( INTEGER meshID, INTEGER size, INTEGER ids(size), DOUBLE PRECISION coordinates(dim*size))</p>
<p>IN: meshID, size OUT: ids, coordinates</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>corresponding mesh ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>return value of <code>getMeshVertexSize()</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>ids corresponding to the coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coordinates</td><td>the coordinates associated to the <code>ids</code> and corresponding data values (dim * <code>size</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>IDs and coordinates need to have the correct size, which can be queried by <code>getMeshVertexSize()</code> </dd>
<dd>
This function can be called on received meshes as well as provided meshes. However, you need to call this function after <code>initialize()</code>, if the <code>meshID</code> corresponds to a received mesh, since the relevant mesh data is exchanged during the <code>initialize()</code> call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00486">486</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_ae96f7b0cf06b414eafa58b7255aff071_cgraph.svg" width="438" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a091ddb804011840dff5b54807cff39b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091ddb804011840dff5b54807cff39b1">&#9670;&nbsp;</a></span>precicef_get_version_information_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_version_information_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>versionInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00467">467</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="ae162bb4c9e9d90699019e36d2486436c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae162bb4c9e9d90699019e36d2486436c">&#9670;&nbsp;</a></span>precicef_get_vertex_ids_from_positions_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_vertex_ids_from_positions_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets mesh vertex IDs from positions. </p>
<p>Fortran syntax: precicef_get_vertices( INTEGER meshID, INTEGER size, DOUBLE PRECISION positions(dim*size), INTEGER ids(size))</p>
<p>IN: meshID, size, positions OUT: ids</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to retrieve positions from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of vertices to lookup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>Positions to find ids for. The 2D-format is (d0x, d0y, d1x, d1y, ..., dnx, dny) The 3D-format is (d0x, d0y, d0z, d1x, d1y, d1z, ..., dnx, dny, dnz) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>IDs corresponding to positions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at positions matches the configured dimension * size </dd>
<dd>
count of available elements at ids matches size</dd></dl>
<dl class="section note"><dt>Note</dt><dd>prefer to reuse the IDs returned from calls to setMeshVertex() and setMeshVertices(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00260">260</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_ae162bb4c9e9d90699019e36d2486436c_cgraph.svg" width="392" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acf01967f1a0f1af51ecc3f058ebb72bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf01967f1a0f1af51ecc3f058ebb72bd">&#9670;&nbsp;</a></span>precicef_get_vertices_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_get_vertices_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vertex positions for multiple vertex ids from a given mesh. </p>
<p>Fortran syntax: precicef_get_vertices( INTEGER meshID, INTEGER size, INTEGER ids(size) DOUBLE PRECISION positions(dim*size))</p>
<p>IN: meshID, size, ids OUT: positions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the mesh to read the vertices from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of vertices to lookup </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>The ids of the vertices to lookup </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">positions</td><td>a pointer to memory to write the coordinates to The 2D-format is (d0x, d0y, d1x, d1y, ..., dnx, dny) The 3D-format is (d0x, d0y, d0z, d1x, d1y, d1z, ..., dnx, dny, dnz)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at positions matches the configured dimension * size </dd>
<dd>
count of available elements at ids matches size</dd></dl>
<dl class="section see"><dt>See also</dt><dd>getDimensions() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00250">250</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_acf01967f1a0f1af51ecc3f058ebb72bd_cgraph.svg" width="402" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a55bd44bb3faffcec7ce1643e1f499bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bd44bb3faffcec7ce1643e1f499bc3">&#9670;&nbsp;</a></span>precicef_has_data_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_has_data_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hasData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthDataName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the data with given name is used by a solver and mesh. </p>
<p>Fortran syntax: precicef_has_data( CHARACTER dataName(*), INTEGER meshID, INTEGER hasData)</p>
<p>IN: dataName IN: meshID OUT: hasData(1:true, 0:false)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataName</td><td>the name of the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the associated mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the mesh is used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00183">183</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a55bd44bb3faffcec7ce1643e1f499bc3_cgraph.svg" width="416" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1f56518e6cb3846798253b29e017be11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f56518e6cb3846798253b29e017be11">&#9670;&nbsp;</a></span>precicef_has_mesh_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_has_mesh_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hasMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthMeshName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the mesh with given name is used by a solver. </p>
<p>Fortran syntax: precicef_has_mesh( CHARACTER meshName(*), INTEGER hasMesh )</p>
<p>IN: meshName OUT: hasMesh(1:true, 0:false)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshName</td><td>the name of the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the mesh is used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00157">157</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a1f56518e6cb3846798253b29e017be11_cgraph.svg" width="424" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abc9fcca05be3dcd084c6b62f1abb0414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9fcca05be3dcd084c6b62f1abb0414">&#9670;&nbsp;</a></span>precicef_initialize_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_initialize_ </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>timestepLengthLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully initializes preCICE and coupling data. </p>
<p>Fortran syntax: precicef_initialize( DOUBLE PRECISION timstepLengthLimit )</p>
<p>IN: - OUT: timestepLengthLimit</p>
<ul>
<li>Sets up a connection to the other participants of the coupled simulation.</li>
</ul>
<p>Creates all meshes, solver meshes need to be submitted before.</p><ul>
<li>Receives first coupling data. The starting values for coupling data are zero by default.</li>
<li>Determines length of the first timestep to be computed.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has not yet been called.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Parallel communication to the coupling partner(s) is setup. </dd>
<dd>
Meshes are exchanged between coupling partners and the parallel partitions are created. </dd>
<dd>
Initial coupling data was exchanged.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum length of first timestep to be computed by the solver. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00059">59</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a6d3fa84325285fa8313d911a6701d20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3fa84325285fa8313d911a6701d20b">&#9670;&nbsp;</a></span>precicef_is_action_required_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_is_action_required_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the provided action is required. </p>
<p>Fortran syntax: precicef_is_action_required( CHARACTER action(*), INTEGER isRequired )</p>
<p>IN: action OUT: isRequired(1:true, 0:false)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>the name of the action </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the action is required</dd></dl>
<p>Some features of preCICE require a solver to perform specific actions, in order to be in valid state for a coupled simulation. A solver is made eligible to use those features, by querying for the required actions, performing them on demand, and calling markActionFulfilled() to signalize preCICE the correct behavior of the solver.</p>
<dl class="section see"><dt>See also</dt><dd>markActionFulfilled() </dd>
<dd>
cplscheme::constants </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00123">123</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a6d3fa84325285fa8313d911a6701d20b_cgraph.svg" width="408" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a68016ecdd5108f00757cbad3a5f81f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68016ecdd5108f00757cbad3a5f81f02">&#9670;&nbsp;</a></span>precicef_is_coupling_ongoing_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_is_coupling_ongoing_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isOngoing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the coupled simulation is still ongoing. </p>
<p>Fortran syntax: precicef_is_coupling_ongoing( INTEGER isOngoing )</p>
<p>IN: - OUT: isOngoing(1:true, 0:false)</p>
<dl class="section return"><dt>Returns</dt><dd>whether the coupling is ongoing.</dd></dl>
<p>A coupling is ongoing as long as</p><ul>
<li>the maximum number of time windows has not been reached, and</li>
<li>the final time has not been reached.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has been called successfully.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>advance()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The user should call finalize() after this function returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00093">93</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a702560446f6d3a307e3f292e8b2c5b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702560446f6d3a307e3f292e8b2c5b18">&#9670;&nbsp;</a></span>precicef_is_gradient_data_required_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_is_gradient_data_required_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given data set requires gradient data. We check if the data object has been initialized with the gradient flag. </p>
<p>Fortran syntax: precicef_is_gradient_data_required_( INTEGER dataID, INTEGER required )</p>
<p>IN: dataID OUT: required(1:true, 0:false)</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<p>preCICE may require gradient data information from the solver and ignores any API calls regarding gradient data if it is not required. (When applying a nearest-neighbor-gradient mapping)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>the id of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether gradient is required </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00496">496</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a4c454ddcb88e2a05cb7aa0977199ec8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c454ddcb88e2a05cb7aa0977199ec8e">&#9670;&nbsp;</a></span>precicef_is_mesh_connectivity_required_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_is_mesh_connectivity_required_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given mesh requires connectivity. </p>
<p>Fortran syntax: precicef_has_data( INTEGER meshID INTEGER required)</p>
<p>IN: meshID OUT: required(1:true, 0:false)</p>
<p>preCICE may require connectivity information from the solver and ignores any API calls regarding connectivity if it is not required. Use this function to conditionally generate this connectivity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether connectivity is required </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00211">211</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a9656f4f1c15f61423889312e2876d164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9656f4f1c15f61423889312e2876d164">&#9670;&nbsp;</a></span>precicef_is_time_window_complete_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_is_time_window_complete_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isComplete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the current coupling window is completed. </p>
<p>Fortran syntax: precicef_is_time_window_complete( INTEGER isComplete );</p>
<p>IN: - OUT: isComplete(1:true, 0:false)</p>
<dl class="section return"><dt>Returns</dt><dd>whether the current time window is complete.</dd></dl>
<p>The following reasons require several solver time steps per time window:</p><ul>
<li>A solver chooses to perform subcycling, i.e. using a smaller timestep than the time window.</li>
<li>An implicit coupling iteration is not yet converged.</li>
</ul>
<p>Hence, a time window is complete if we reach the end of the time window and the implicit coupling has converged.</p>
<p>For implicit coupling this condition is equivalent with the requirement to write an iteration checkpoint. This is, however, not the case for explicit coupling.</p>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has been called successfully. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00104">104</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a018c649ec371258d4f08d57713a9687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018c649ec371258d4f08d57713a9687d">&#9670;&nbsp;</a></span>precicef_mark_action_fulfilled_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_mark_action_fulfilled_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lengthAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates preCICE that a required action has been fulfilled by a solver. </p>
<p>Fortran syntax: precicef_mark_action_fulfilled( CHARACTER action(*) )</p>
<p>IN: action OUT: -</p>
<dl class="section pre"><dt>Precondition</dt><dd>The solver fulfilled the specified action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>the name of the action</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>requireAction() </dd>
<dd>
cplscheme::constants </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00147">147</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a018c649ec371258d4f08d57713a9687d_cgraph.svg" width="432" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af835e0a7ff5ee538130739fdd8ac2fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af835e0a7ff5ee538130739fdd8ac2fa9">&#9670;&nbsp;</a></span>precicef_ongoing_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void precicef_ongoing_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>isOngoing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Forwards to precicef_is_coupling_ongoing_</dd></dl>
<p>Fortran syntax: precicef_ongoing( INTEGER isOngoing )</p>
<p>IN: - OUT: isOngoing(1:true, 0:false)</p>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00087">87</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_af835e0a7ff5ee538130739fdd8ac2fa9_cgraph.svg" width="354" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a848befad97e6f37a2547f14ebb579cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848befad97e6f37a2547f14ebb579cb3">&#9670;&nbsp;</a></span>precicef_read_bsdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_read_bsdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valueIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads scalar data values given as block from a mesh. Values correspond to the end of the current time window. </p>
<p>Fortran syntax: precicef_read_bsdata( INTEGER dataID, INTEGER size, INTEGER valueIndices, DOUBLE PRECISION values(size) )</p>
<p>IN: dataID, size, valueIndices OUT: values</p>
<p>This function reads values of specified vertices from a dataID. Values are provided as a block of continuous memory. valueIndices contains the indices of the vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number n of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndices</td><td>Indices of the vertices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Pointer to the read destination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at values matches the given size </dd>
<dd>
count of available elements at valueIndices matches the given size </dd>
<dd>
initialize() has been called</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>values contains the read data.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00404">404</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a848befad97e6f37a2547f14ebb579cb3_cgraph.svg" width="402" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4d5df9e3756f761649a05cb124d66c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5df9e3756f761649a05cb124d66c82">&#9670;&nbsp;</a></span>precicef_read_bvdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_read_bvdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valueIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads vector data values given as block from a mesh. Values correspond to the end of the current time window. </p>
<p>Fortran syntax: precicef_read_bvdata( INTEGER dataID, INTEGER size, INTEGER valueIndices, DOUBLE PRECISION values(dim*size) )</p>
<p>IN: dataID, size, valueIndices OUT: values</p>
<p>This function reads values of specified vertices from a dataID. Values are read into a block of continuous memory. valueIndices contains the indices of the vertices.</p>
<p>The 2D-format of values is (d0x, d0y, d1x, d1y, ..., dnx, dny) The 3D-format of values is (d0x, d0y, d0z, d1x, d1y, d1z, ..., dnx, dny, dnz)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number n of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndices</td><td>Indices of the vertices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Pointer to read destination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at values matches the configured dimension * size </dd>
<dd>
count of available elements at valueIndices matches the given size </dd>
<dd>
initialize() has been called</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>values contain the read data as specified in the above format.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00385">385</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a4d5df9e3756f761649a05cb124d66c82_cgraph.svg" width="403" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af24364703bad142cc933a62b8f8989b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24364703bad142cc933a62b8f8989b2">&#9670;&nbsp;</a></span>precicef_read_sdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_read_sdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dataValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads scalar data at a vertex on a mesh. Values correspond to the end of the current time window. </p>
<p>Fortran syntax: precicef_read_sdata( INTEGER dataID, INTEGER valueIndex, DOUBLE PRECISION dataValue )</p>
<p>IN: dataID, valueIndex OUT: dataValue</p>
<p>This function reads a value of a specified vertex from a dataID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndex</td><td>Index of the vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Read destination of the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has been called</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>value contains the read data.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00414">414</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a79b96e17d6d06a6190df8f1d669d7c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b96e17d6d06a6190df8f1d669d7c35">&#9670;&nbsp;</a></span>precicef_read_vdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_read_vdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dataValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads vector data at a vertex on a mesh. Values correspond to the end of the current time window. </p>
<p>Fortran syntax: precicef_read_vdata( INTEGER dataID, INTEGER valueIndex, DOUBLE PRECISION dataValue(dim) )</p>
<p>IN: dataID, valueIndex OUT: dataValue</p>
<p>This function reads a value of a specified vertex from a dataID. Values are provided as a block of continuous memory.</p>
<p>The 2D-format of value is (x, y) The 3D-format of value is (x, y, z)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndex</td><td>Index of the vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Pointer to the vector value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at value matches the configured dimension </dd>
<dd>
initialize() has been called</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>value contains the read data as specified in the above format.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00395">395</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a4bccd3a896f283222c2084b0815b1113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bccd3a896f283222c2084b0815b1113">&#9670;&nbsp;</a></span>precicef_set_edge_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_edge_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondVertexID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a mesh edge from vertex IDs. </p>
<p>Fortran syntax: precicef_set_edge( INTEGER meshID, INTEGER firstVertexID, INTEGER secondVertexID )</p>
<p>IN: meshID, firstVertexID, secondVertexID OUT: -</p>
<dl class="section note"><dt>Note</dt><dd>The order of vertices does not matter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the edge to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVertexID</td><td>ID of the first vertex of the edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVertexID</td><td>ID of the second vertex of the edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices with firstVertexID and secondVertexID were added to the mesh with the ID meshID </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00270">270</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a18998f476f957f0bfe28631e1fcc7228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18998f476f957f0bfe28631e1fcc7228">&#9670;&nbsp;</a></span>precicef_set_mesh_access_region_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_mesh_access_region_ </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>boundingBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setMeshAccessRegion Define a region of interest on a received mesh (&lt;receive-mesh ... from="otherParticipant /&gt;") in order to receive only a certain mesh region. Have a look at the website under <a href="https://precice.org/couple-your-code-direct-access.html">https://precice.org/couple-your-code-direct-access.html</a> or navigate manually to the page Docs-&gt;Couple your code -&gt; Advanced topics -&gt; Accessing received meshes directly for a comprehensive documentation </p>
<p>Fortran syntax: precicef_set_mesh_access_region_( INTEGER meshID, DOUBLE PRECISION bounding_box(dim*2))</p>
<p>IN: meshID, bounding_box OUT: -</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<p>This function is required if you don't want to use the mapping schemes in preCICE, but rather want to use your own solver for data mapping. As opposed to the usual preCICE mapping, only a single mesh (from the other participant) is now involved in this situation since an 'own' mesh defined by the participant itself is not required any more. In order to re-partition the received mesh, the participant needs to define the mesh region it wants read data from and write data to. The mesh region is specified through an axis-aligned bounding box given by the lower and upper [min and max] bounding-box limits in each space dimension [x, y, z].</p>
<dl class="section note"><dt>Note</dt><dd>Defining a bounding box for serial runs of the solver (not to be confused with serial coupling mode) is valid. However, a warning is raised in case vertices are filtered out completely on the receiving side, since the associated data values of the filtered vertices are filled with zero data.</dd>
<dd>
This function can only be called once per participant and rank and trying to call it more than once results in an error.</dd>
<dd>
If you combine the direct access with a mpping (say you want to read data from a defined mesh, as usual, but you want to directly access and write data on a received mesh without a mapping) you may not need this function at all since the region of interest is already defined through the defined mesh used for data reading. This is the case if you define any mapping involving the directly accessed mesh on the receiving participant. (In parallel, only the cases read-consistent and write-conservative are relevant, as usual).</dd>
<dd>
The safety factor scaling (see safety-factor in the configuration file) is not applied to the defined access region and a specified safety will be ignored in case there is no additional mapping involved. However, in case a mapping is in addition to the direct access involved, you will receive (and gain access to) vertices inside the defined access region plus vertices inside the safety factor region resulting from the mapping. The default value of the safety factor is 0.5,i.e., the defined access region as computed through the involved provided mesh is by 50% enlarged.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh you want to access through the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundingBox</td><td>Axis aligned bounding boxes which has in 3D the format [x_min, x_max, y_min, y_max, z_min, z_max]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>initialize()</code> has not yet been called. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00478">478</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a7b5cfece0a1721e234688f34fd1dd984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5cfece0a1721e234688f34fd1dd984">&#9670;&nbsp;</a></span>precicef_set_mesh_edges_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_mesh_edges_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multiple mesh edge from vertex IDs. </p>
<p>Sets multiple mesh triangles from vertex IDs.</p>
<p>Fortran syntax: precicef_set_mesh_edges_( INTEGER meshID, INTEGER size, INTEGER vertices(size*2) )</p>
<p>IN: meshID, size, vertices OUT: -</p>
<p>vertices contain pairs of vertex indices for each edge to define. The format follows: e1a, e1b, e2a, e2b, ...</p>
<dl class="section note"><dt>Note</dt><dd>The order of vertices per edge does not matter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the edges to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the amount of edges to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>an array containing 2*size vertex IDs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired()</dd></dl>
<p>Fortran syntax: precicef_set_mesh_triangles_( INTEGER meshID, INTEGER size, INTEGER vertices(size*3) )</p>
<p>IN: meshID, size, vertices OUT: -</p>
<p>vertices contain triples of vertex indices for each triangle to define. The format follows: t1a, t1b, t1c, t2a, t2b, t2c, ...</p>
<dl class="section note"><dt>Note</dt><dd>The order of vertices per triangle does not matter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the triangles to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the amount of triangles to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>an array containing 3*size vertex IDs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00279">279</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a7b5cfece0a1721e234688f34fd1dd984_cgraph.svg" width="431" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa5d65a5422d2408c820ba4f5c5f17868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d65a5422d2408c820ba4f5c5f17868">&#9670;&nbsp;</a></span>precicef_set_mesh_quads_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_mesh_quads_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multiple mesh quads from vertex IDs. </p>
<p>Fortran syntax: precicef_set_mesh_quads( INTEGER meshID, INTEGER size, INTEGER vertices(size*4) )</p>
<p>IN: meshID, size, vertices OUT: -</p>
<p>vertices contain quadruples of vertex indices for each quad to define. The format follows: q1a, q1b, q1c, q1d, q2a, q2b, q2c, q2d, ...</p>
<p>Each planar quad will be triangulated, maximizing area-to-circumference.</p>
<dl class="section warning"><dt>Warning</dt><dd>The order of vertices per quad does not matter, however, only planar quads are allowed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the quad to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the amount of quads to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>an array containing 4*size vertex IDs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00318">318</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_aa5d65a5422d2408c820ba4f5c5f17868_cgraph.svg" width="431" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a16bd62b234cadc370d120e6ec83cd142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bd62b234cadc370d120e6ec83cd142">&#9670;&nbsp;</a></span>precicef_set_mesh_tetrahedra_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_mesh_tetrahedra_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multiple mesh tetrahedra from vertex IDs. </p>
<p>Fortran syntax: precicef_set_mesh_tetrahedra_( INTEGER meshID, INTEGER size, INTEGER vertices(size*4) )</p>
<p>IN: meshID, size, vertices OUT: -</p>
<p>vertices contain quadruples of vertex indices for each tetrahedron to define. The format follows: t1a, t1b, t1c, t1d, t2a, t2b, t2c, t2d, ...</p>
<dl class="section note"><dt>Note</dt><dd>The order of vertices per tetrahedron does not matter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the tetrahedra to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the amount of tetrahedra to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>an array containing 4*size vertex IDs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00338">338</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a16bd62b234cadc370d120e6ec83cd142_cgraph.svg" width="460" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a960303a9aa514bc53f8a3fa5077221e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960303a9aa514bc53f8a3fa5077221e5">&#9670;&nbsp;</a></span>precicef_set_quad_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_quad_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>thirdVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fourthVertexID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a planar surface mesh quadrangle from vertex IDs. </p>
<p>Fortran syntax: precicef_set_quad_( INTEGER meshID, INTEGER firstVertexID, INTEGER secondVertexID, INTEGER thirdVertexID, INTEGER fourthVertexID )</p>
<p>IN: meshID, firstVertexID, secondVertexID, thirdVertexID, fourthVertexID OUT: -</p>
<p>The planar quad will be triangulated, maximizing area-to-circumference.</p>
<dl class="section warning"><dt>Warning</dt><dd>The order of vertices does not matter, however, only planar quads are allowed.</dd>
<dd>
For setting multiple quads, prefer the vastly more efficient setMeshQuads().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the Quad to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVertexID</td><td>ID of the first vertex of the Quad </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVertexID</td><td>ID of the second vertex of the Quad </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdVertexID</td><td>ID of the third vertex of the Quad </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fourthVertexID</td><td>ID of the fourth vertex of the Quad</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices with firstVertexID, secondVertexID, thirdVertexID, and fourthVertexID were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00307">307</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a2e219ea4d5f59d6289e2c6b415804492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e219ea4d5f59d6289e2c6b415804492">&#9670;&nbsp;</a></span>precicef_set_tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_tetrahedron </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>thirdVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fourthVertexID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set tetrahedron in 3D mesh from vertex ID. </p>
<p>Fortran syntax: precicef_set_tetrahedron( INTEGER meshID, INTEGER firstVertexID, INTEGER secondVertexID, INTEGER thirdVertexID, INTEGER fourthVertexID )</p>
<p>IN: meshID, firstVertexID, secondVertexID, thirdVertexID, fourthVertexID OUT: -</p>
<dl class="section note"><dt>Note</dt><dd>The order of vertices does not matter.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For setting multiple tetrahedra, prefer the vastly more efficient setMeshTetrahedra().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the Tetrahedron to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVertexID</td><td>ID of the first vertex of the Tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVertexID</td><td>ID of the second vertex of the Tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdVertexID</td><td>ID of the third vertex of the Tetrahedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fourthVertexID</td><td>ID of the fourth vertex of the Tetrahedron</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>vertices with firstVertexID, secondVertexID, thirdVertexID, and fourthVertexID were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00327">327</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a45d85060651c172402e56cb020130021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d85060651c172402e56cb020130021">&#9670;&nbsp;</a></span>precicef_set_triangle_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_triangle_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>firstVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>secondVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>thirdVertexID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets mesh triangle from vertex IDs. </p>
<p>Fortran syntax: precicef_set_triangle_( INTEGER meshID, INTEGER firstVertexID, INTEGER secondVertexID, INTEGER thirdVertexID )</p>
<p>IN: meshID, firstVertexID, secondVertexID, thirdVertexID OUT: -</p>
<dl class="section note"><dt>Note</dt><dd>The order of vertices does not matter.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For setting multiple triangle, prefer the vastly more efficient setMeshTriangles().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>ID of the mesh to add the triangle to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVertexID</td><td>ID of the first vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVertexID</td><td>ID of the second vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thirdVertexID</td><td>ID of the third vertex of the triangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>edges with firstVertexID, secondVertexID, and thirdVertexID were added to the mesh with the ID meshID</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isMeshConnectivityRequired() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00288">288</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a448b90ad9522fad694e8d75c5bb58ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448b90ad9522fad694e8d75c5bb58ee3">&#9670;&nbsp;</a></span>precicef_set_vertex_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_vertex_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>vertexID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mesh vertex. </p>
<p>Fortran syntax: precicef_set_vertex( INTEGER meshID, DOUBLE PRECISION position(dim), INTEGER vertexID )</p>
<p>IN: meshID, position OUT: vertexID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the mesh to add the vertex to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>a pointer to the coordinates of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the created vertex</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has not yet been called </dd>
<dd>
count of available elements at position matches the configured dimension</dd></dl>
<dl class="section see"><dt>See also</dt><dd>getDimensions() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00223">223</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a0282309e6095d5cece8e77f980d4ffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0282309e6095d5cece8e77f980d4ffd9">&#9670;&nbsp;</a></span>precicef_set_vertices_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_set_vertices_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>meshID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>positionIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates multiple mesh vertices. </p>
<p>Fortran syntax: precicef_set_vertices( INTEGER meshID, INTEGER size, DOUBLE PRECISION positions(dim*size), INTEGER positionIDs(size) )</p>
<p>IN: meshID, size, positions OUT: positionIDs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshID</td><td>the id of the mesh to add the vertices to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of vertices to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>a pointer to the coordinates of the vertices The 2D-format is (d0x, d0y, d1x, d1y, ..., dnx, dny) The 3D-format is (d0x, d0y, d0z, d1x, d1y, d1z, ..., dnx, dny, dnz)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>The ids of the created vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has not yet been called </dd>
<dd>
count of available elements at positions matches the configured dimension * size </dd>
<dd>
count of available elements at ids matches size</dd></dl>
<dl class="section see"><dt>See also</dt><dd>getDimensions() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00240">240</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a0282309e6095d5cece8e77f980d4ffd9_cgraph.svg" width="400" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a63d504dd8043f8e8e293db5fdf27e012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d504dd8043f8e8e293db5fdf27e012">&#9670;&nbsp;</a></span>precicef_write_bsdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_bsdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valueIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes scalar data given as block. </p>
<p>Fortran syntax: precicef_write_bsdata( INTEGER dataID, INTEGER size, INTEGER valueIndices, DOUBLE PRECISION values(size) )</p>
<p>IN: dataID, size, valueIndices, values OUT: -</p>
<p>This function writes values of specified vertices to a dataID. Values are provided as a block of continuous memory. valueIndices contains the indices of the vertices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number n of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndices</td><td>Indices of the vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Pointer to the values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at values matches the given size </dd>
<dd>
count of available elements at valueIndices matches the given size </dd>
<dd>
initialize() has been called</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00366">366</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a63d504dd8043f8e8e293db5fdf27e012_cgraph.svg" width="406" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6bd135b00dfc8b28a17f668ebf380e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd135b00dfc8b28a17f668ebf380e18">&#9670;&nbsp;</a></span>precicef_write_bsgradient_data_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_bsgradient_data_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>gradientValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes scalar gradient data given as block. </p>
<p>Fortran syntax: precicef_write_bsgradient_data_( INTEGER dataID, INTEGER size, INTEGER valueIndices, DOUBLE PRECISION gradientValues )</p>
<p>IN: dataID, size, valueIndices, gradientValues OUT: -</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<p>This function writes values of specified vertices to a dataID. Values are provided as a block of continuous memory. valueIndices contains the indices of the vertices</p>
<p>The gradients need to be provided in the following format:</p>
<p>The 2D-format of <code>gradientValues</code> is (v0_dx, v0_dy, v1_dx, v1_dy, ... , vn_dx, vn_dy, vn_dz) corresponding to the scalar data v0, v1, ... , vn differentiated in spatial directions x and y.</p>
<p>The 3D-format of <code>gradientValues</code> is (v0_dx, v0_dy, v0_dz, v1_dx, v1_dy, v1_dz, ... , vn_dx, vn_dy, vn_dz) corresponding to the scalar data v0, v1, ... , vn differentiated in spatial directions x, y and z.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number n of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndices</td><td>Indices of the vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradientValues</td><td>Pointer to the gradient values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at values matches the given size </dd>
<dd>
count of available elements at valueIndices matches the given size </dd>
<dd>
initialize() has been called </dd>
<dd>
Data with dataID has attribute hasGradient = true</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00515">515</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a6bd135b00dfc8b28a17f668ebf380e18_cgraph.svg" width="424" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a68fd666371672a87a6e6b4ee7267e1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fd666371672a87a6e6b4ee7267e1ab">&#9670;&nbsp;</a></span>precicef_write_bvdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_bvdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>valueIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes vector data given as block. </p>
<p>Fortran syntax: precicef_write_bvdata( INTEGER dataID, INTEGER size, INTEGER valueIndices, DOUBLE PRECISION values(dim*size) )</p>
<p>IN: dataID, size, valueIndices, values OUT: -</p>
<p>This function writes values of specified vertices to a dataID. Values are provided as a block of continuous memory. valueIndices contains the indices of the vertices</p>
<p>The 2D-format of values is (d0x, d0y, d1x, d1y, ..., dnx, dny) The 3D-format of values is (d0x, d0y, d0z, d1x, d1y, d1z, ..., dnx, dny, dnz)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number n of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndices</td><td>Indices of the vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Pointer to the vector values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at values matches the configured dimension * size </dd>
<dd>
count of available elements at valueIndices matches the given size </dd>
<dd>
initialize() has been called</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00347">347</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_a68fd666371672a87a6e6b4ee7267e1ab_cgraph.svg" width="407" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa61ef25602fbde42bb43521958fd65dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61ef25602fbde42bb43521958fd65dd">&#9670;&nbsp;</a></span>precicef_write_bvgradient_data_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_bvgradient_data_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>gradientValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes vector gradient data given as block. </p>
<p>Fortran syntax: precicef_write_bvgradient_data_( INTEGER dataID, INTEGER size, INTEGER valueIndices, DOUBLE PRECISION gradientValues )</p>
<p>IN: dataID, size, valueIndices, gradientValues OUT: -</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<p>This function writes values of specified vertices to a dataID. Values are provided as a block of continuous memory. <code>valueIndices</code> contains the indices of the vertices</p>
<p>The values are passed in the same format applied in writeVectorGradientData() for each data vertex:</p>
<p>The 2D-format of <code>gradientValues</code> is ( v0x_dx, v0y_dx, v0x_dy, v0y_dy, v1x_dx, v1y_dx, v1x_dy, v1y_dy, ... , vnx_dx, vny_dx, vnx_dy, vny_dy)</p>
<p>corresponding to the vector data v0 = (v0x, v0y) , v1 = (v1x, v1y), ... , vn = (vnx, vny) differentiated in spatial directions x and y.</p>
<p>The 3D-format of <code>gradientValues</code> is ( v0x_dx, v0y_dx, v0z_dx, v0x_dy, v0y_dy, v0z_dy, v0x_dz, v0y_dz, v0z_dz, v1x_dx, v1y_dx, v1z_dx, v1x_dy, v1y_dy, v1z_dy, v1x_dz, v1y_dz, v1z_dz, ... , vnx_dx, vny_dx, vnz_dx, vnx_dy, vny_dy, vnz_dy, vnx_dz, vny_dz, vnz_dz)</p>
<p>corresponding to the vector data v0 = (v0x, v0y, v0z) , v1 = (v1x, v1y, v1z), ... , vn = (vnx, vny, vnz) differentiated in spatial directions x,y and z.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number n of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndices</td><td>Indices of the vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradientValues</td><td>Pointer to the gradient values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at gradient values matches the configured dimension * size </dd>
<dd>
count of available elements at valueIndices matches the given size </dd>
<dd>
initialize() has been called </dd>
<dd>
Data with dataID has attribute hasGradient = true</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00534">534</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="SolverInterfaceFortran_8hpp_aa61ef25602fbde42bb43521958fd65dd_cgraph.svg" width="424" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac98005b1ae5940cdecdf8866784e8c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98005b1ae5940cdecdf8866784e8c04">&#9670;&nbsp;</a></span>precicef_write_sdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_sdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes scalar data to a vertex. </p>
<p>Fortran syntax: precicef_write_sdata( INTEGER dataID, INTEGER valueIndex, DOUBLE PRECISION dataValue )</p>
<p>IN: dataID, valueIndex, dataValue OUT: -</p>
<p>This function writes a value of a specified vertex to a dataID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndex</td><td>Index of the vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>initialize() has been called</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00376">376</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="af160c41c24197f348459bc9d400dee5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af160c41c24197f348459bc9d400dee5c">&#9670;&nbsp;</a></span>precicef_write_sgradient_data_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_sgradient_data_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>gradientValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes scalar gradient data to a vertex. </p>
<p>Fortran syntax: precicef_write_sgradient_data_( INTEGER dataID, INTEGER valueIndex, DOUBLE PRECISION gradientValues )</p>
<p>IN: dataID, valueIndex, gradientValues OUT: -</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<p>This function writes a the corresponding gradient value of a specified vertex to a dataID. Values are provided as a block of continuous memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndex</td><td>Index of the vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradientValues</td><td>Gradient values differentiated in the spacial direction (dx, dy) for 2D space, (dx, dy, dz) for 3D space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at value matches the configured dimension </dd>
<dd>
initialize() has been called </dd>
<dd>
vertex with dataID exists and contains data </dd>
<dd>
Data with dataID has attribute hasGradient = true</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00506">506</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="a5bf9e3af0454b813fb64a6d7ca10da63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf9e3af0454b813fb64a6d7ca10da63">&#9670;&nbsp;</a></span>precicef_write_vdata_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_vdata_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dataValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes vector data to a vertex. </p>
<p>Fortran syntax: precicef_write_vdata( INTEGER dataID, INTEGER valueIndex, DOUBLE PRECISION dataValue(dim) )</p>
<p>IN: dataID, valueIndex, dataValue OUT: -</p>
<p>This function writes a value of a specified vertex to a dataID. Values are provided as a block of continuous memory.</p>
<p>The 2D-format of value is (x, y) The 3D-format of value is (x, y, z)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndex</td><td>Index of the vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Pointer to the vector value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at value matches the configured dimension </dd>
<dd>
initialize() has been called</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00357">357</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
<a id="ac3abc96e19d89d277a2a2ad02805e27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3abc96e19d89d277a2a2ad02805e27d">&#9670;&nbsp;</a></span>precicef_write_vgradient_data_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PRECICE_API void precicef_write_vgradient_data_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dataID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>valueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>gradientValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes vector gradient data to a vertex. </p>
<p>Fortran syntax: precicef_write_vgradient_data_( INTEGER dataID, INTEGER valueIndex, DOUBLE PRECISION gradientValues )</p>
<p>IN: dataID, valueIndex, gradientValues OUT: -</p>
<dl class="section attention"><dt>Attention</dt><dd>This API function is <b>experimental</b> and may change in the future!</dd></dl>
<p>This function writes the corresponding gradient matrix value of a specified vertex to a dataID. Values are provided as a block of continuous memory.</p>
<p>The gradients need to be provided in the following format:</p>
<p>The 2D-format of <code>gradientValues</code> is (vx_dx, vy_dx, vx_dy, vy_dy) matrix corresponding to the data block v = (vx, vy) differentiated respectively in x-direction dx and y-direction dy</p>
<p>The 3D-format of <code>gradientValues</code> is (vx_dx, vy_dx, vz_dx, vx_dy, vy_dy, vz_dy, vx_dz, vy_dz, vz_dz) matrix corresponding to the data block v = (vx, vy, vz) differentiated respectively in spatial directions x-direction dx and y-direction dy and z-direction dz</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataID</td><td>ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueIndex</td><td>Index of the vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradientValue</td><td>pointer to the gradient value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>count of available elements at value matches the configured dimension </dd>
<dd>
initialize() has been called </dd>
<dd>
vertex with dataID exists and contains data </dd>
<dd>
Data with dataID has attribute hasGradient = true</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SolverInterface::setMeshVertex() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SolverInterfaceFortran_8cpp_source.html#l00525">525</a> of file <a class="el" href="SolverInterfaceFortran_8cpp_source.html">SolverInterfaceFortran.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
